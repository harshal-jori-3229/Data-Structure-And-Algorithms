/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */


 class MinHeap {
    constructor(){
        this.heap = [];
    }
    size(){
        return this.heap.length;
    }
    top(){
        return this.heap[0];
    }
    push(val){
        this.heap.push(val);
        this.heapifyUP();
    }
    pop(){
        if(this.size() === 1)return this.heap.pop();
        const root = this.heap[0];
        this.heap[0] = this.heap.pop();
        this.heapifyDown();
        return root;
    }
    heapifyUP(){
        let i = this.size()-1;
        while(i>0){
            let parentidx = Math.floor((i-1)/2);

            if(this.heap[i] < this.heap[parentidx]){
                [this.heap[i], this.heap[parentidx]] = [this.heap[parentidx],
                this.heap[i]];
                i = parentidx;
            }else {
                break;
            }
        }
    }
    heapifyDown(){
        let i = 0; 
        let n = this.size();
        while(true){
            let left = 2 * i + 1;
            let right = 2 * i + 2;
            let smallest = i;

            if(left < n && this.heap[left] < this.heap[smallest]){
                smallest = left;
            }
            if(right < n && this.heap[right] < this.heap[smallest]){
                smallest = right;
            }
            if(smallest != i){
                [this.heap[i], this.heap[smallest]] = [this.heap[smallest],
                 this.heap[i]];

                 i = smallest
            }else{
                break;
            }
        }
    }

 }
var findKthLargest = function(nums, k) {
    let minPQ = new MinHeap();
    let n = nums.length;

    for(i=0; i<k; i++){
        minPQ.push(nums[i]);
    }

    for(i=k; i<n; i++){
        if(nums[i] > minPQ.top()){
            minPQ.pop();
            minPQ.push(nums[i]);
        }
    }

    return minPQ.top();

};
